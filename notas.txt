Instalaciones Necesarias
-Google Chrome
-Postman
-visual studio code
	instalar el plugin: html css support
	instalar el plugin: JavaScript(ES6) code snippets
	instalar el plugin: js-css-html Formatter
	instalar el plugin: terminal
	instalar el plugin: TypeScript Importer
-git
-node
SECCION 2
¿Que es Node?
Es javascript del lado del servidor
Lenguaje de BAckend
Acceso al sisteema de archivos del equipo
Informacion del Sistema Operativo
Procesos del equipo
utiliza el motor v8

¿Que puedo hacer con Node?
Uso de Sockets para una comunicacion real Cliente-Servidor
Manejo de archivos en FileSystem, cargas simultaneas
Servidores locales y remotos con informacion en tiempo real.
Conexiones a base de datos
Creacion de servicios REST en segundos.

¿Por que Node es tan popular?
Entradas y salidas que no realizan bloqueos del servidor.
Es sumamente rapido y facil de configurar.
Mas de 470 mil paquetes disponibles(El ecosistema con mas librerias en el mundo).
Si sabes JavaScript, ya conoces la mayor parte de Node.

Blocking vs Non Blocking I/O
Basicamente Blocking ejecuta las tareas una a una
mientras el Non Blocking ejecuta las tareas en paralelo es decir asincrono.

HOLA MUNDO
Creamos una carpeta con nombre 01-hola-mundo
Luego dentro de la carpeta creamos un archivo app.js
y colocamos estas instrucciones

let nombre= "Eddy";
console.log('Hola '+nombre);
console.log(`Hola ${ nombre }`);

luego navegamos a este folder y ejecutamos por consola
node app.js

Node funciona con tres bloques
Pila de procesos: Es el main y aca los procesos se ejecutan de manera secuencial
Node Apis: son procesos los cuales estan a la espera de ejecutarse
Cola de callback: son los procesos que estaban en la Node Apis y estan pronto a ejecutarse en la pila de procesos.


NODEMON
Paquetes son codigos que han desarrollado otras personas y nos ayudan a funciones especificas.
Buscamos npm nodemon en el navegador y el siguiente comando es el que debemos ejecutar para instalar nodemon
npm install -g nodemon

Esta instrucion ejecuta el programa y se queda a la espera de los cambios de la applicacion para volver a ejecutarla
nodemon app.js 

LET VRS VAR
El let y el var hacen lo mismo declaran una variable.

VAR
Al declarar la variable var esta funciona globalmente es decir en cualquier punto del codigo se puede redeclarar y reasignar el valor de la variable.

LET
Al declarar una variable con let a esta no se puede redeclarar sin embargo el cambio de valor se puede realizar sin ningun problema siempre se llame a la variable por su nombre y sin utilizar la instruccion let delante del nombre pues esto seria una redeclaracion de variable.

El let es lo que mas se utiliza hoy en dia.


Template String
otra forma de escribir y concatenar en la consola y en variables

console.log(nombre+" "+real);
console.log(`${ nombre } ${ real }`)

function getNombre(){
	return ` ${ nombre } es ${ real } `;
}
console.log(`El nomde de: ${ getNombre() }`);

basicamente utilizando esas pequeñas comillas podemos inyectar javascript


DESCTRUCTURACION
Basicamente es crear varias variables al momento de traer las propiedades de un objeto
y somos capaces de ponerle alias a dichas variables.
let deadpool = {
	nombre: "Wade",
	apellido: "Winston",
	poder: "Regeneracion",
	getNombre: function(){
		return `${ this.nombre } ${ this.apellido } - poder: ${this.poder} `;
	}
};

let { nombre:primerNombre,apellido, poder }=deadpool;

FUNCIONES FLECHA
Basicamente es un cambio en la sintaxi pero hace exactamente lo mismo que una funcion
function sumar(a,b){
	return a + b;
}
En flecha de varias lineas
let sumar = (a,b) =>{
	return a + b;
}
En flecha de una sola linea
let sumar = (a,b) => a + b;

y la llamada se hace como siempre
NOTA: en las funciones flechas si no tiene argumentos(parametros) entonces solo se pone los parentesis vacios y si solo tiene un argumento los parentesis son opcionales.
Para todos los demas siempre van los parentesis.

CallBack
Es una funcion que se ejecuta despues de que algo sucede


let getUsuarioById = (id, callback) => {

	let usuario={
		nombre:"Eddy",
		id
	}
	callback(usuario);
}

getUsuarioById(10,(usuario) => {
	console.log('Usuario de base de datos ', usuario);
});

Primero se declaro una funcion que recibira dos parametros uno es un dato y el otro es una funcion que se ejecutara luego de algun codigo anterior a ella en la funcion principal
en el ejemplo anterior primero se declara el objeto y luego se ejecuta la funcion flecha que recibe el usuario(objeto) y para que todo eso pase llamamos a la funcion principal que en este caso es getUsuarioById

Por lo regular en los callback el primer argumento de la funcion callback es el error para que lo maneje por si sucede

Basicamente ¿Como manejar los errores de callback? es por ello que se utiliza el error como el primer argumento 
Ejemplo

let getUsuarioById = (id, callback) => {

	let usuario={
		nombre:"Eddy",
		id
	}
	if( id===20 ){
		callback(`El usuario con id ${ id }, no existe en la BD`);
	}else{
		callback(null,usuario);
	}
	
}

getUsuarioById(1,(err,usuario) => {
	if( err ){
		return console.log(err);
	}
	console.log('Usuario de base de datos ', usuario);
});

Donde si el valor es difetente de 20 se cumple la condicion es decir no hay error por tanto le pasamos el error como nulo(No entrara en el if del error de la funciona callback) y el usuario para que lo utilice en la funcion callback
Pero si por el coantrario el id es 20 entonces entratria en la parte del error(por que asi lo hemos definido nosotros como ejemplo) y este no enviaria nulo el error al no enviarlo como nulo el argumento el cual es un mensaje de que no existe el usuario se interpretaria como el error mismo y se imprimiria para luego salir del callback 

NOTA: el callback va estar referenciado en la declaracion de la funcion principal, la salida de la funcion principal es la entrada para el callback, al mandar a llamar a la funcion principal se debe declarar el callbak

un callback puede llamar a otra funciona que ya este declarada con otro callback es decir puede  ser recursivos.Pero al ser recursivos el codigo tiende a complicarse mucho.

PROMESAS
Las promesas asi como los callbacks nos pueden ayudar a resolver distintas tareas. Las promesas nos permiten ejecutar un trabajo ya sea asincrono o sincrono y despues de que se resuelva el trabajo realizar otro

Una promesa recibe tres callbacks dos referenciados y uno declarado

let getEmpleado=(id)=>{
	return new Promise( (resolve,reject) =>{
	let empleadoDB=empleados.find(empleado => empleado.id === id);
		if(!empleadoDB){
			reject(`No existe un empleado con el ID ${ id }`)
		}else{
			resolve(empleadoDB);
		}	
	});	
}

al llamar a la funcion padre que devuelve la promesa esta debe declarar las dos promesas que en al declarar la funcion padre solo fueron referenciadas.
Me quede en el video 21
